<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juice WRLD ‚Äì Infinite Abyss Chronicles</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body {
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: 'Courier New', monospace;
}

canvas {
    display: block;
}

/* UI */
.ui {
    position: fixed;
    top: 15px;
    left: 15px;
    text-shadow: 0 0 8px currentColor;
    z-index: 10;
    font-size: 14px;
    transition: color 1s;
}

.ui div {
    margin-bottom: 5px;
}

.score-display {
    font-size: 24px;
    color: #ffd700;
    text-shadow: 0 0 15px #ffd700;
    margin-bottom: 10px;
}

.era-display {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 10px;
    padding: 5px 10px;
    background: rgba(0,0,0,0.7);
    border-radius: 5px;
    border: 2px solid currentColor;
}

.power-bar {
    width: 200px;
    height: 20px;
    background: rgba(0,0,0,0.5);
    border: 2px solid #00ffff;
    border-radius: 10px;
    overflow: hidden;
    margin-top: 5px;
}

.power-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff00ff, #00ffff);
    transition: width 0.3s;
    box-shadow: 0 0 10px #00ffff;
}

.jump-charge-bar {
    width: 150px;
    height: 15px;
    background: rgba(0,0,0,0.5);
    border: 2px solid #00ff00;
    border-radius: 8px;
    overflow: hidden;
    margin-top: 5px;
}

.jump-charge-fill {
    height: 100%;
    background: linear-gradient(90deg, #00ff00, #ffff00);
    transition: width 0.1s;
    box-shadow: 0 0 10px #00ff00;
}

.inventory {
    position: fixed;
    top: 15px;
    right: 15px;
    z-index: 10;
}

.item-slot {
    width: 60px;
    height: 60px;
    background: rgba(0,0,0,0.7);
    border: 2px solid #7f3cff;
    border-radius: 8px;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 10px rgba(127, 60, 255, 0.5);
    position: relative;
}

.item-count {
    position: absolute;
    bottom: 2px;
    right: 5px;
    font-size: 14px;
    font-weight: bold;
    color: #00ffff;
    text-shadow: 0 0 5px #00ffff;
}

/* CONTROLES */
.controls {
    position: fixed;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
    box-sizing: border-box;
    z-index: 10;
}

#joystick {
    width: 120px;
    height: 120px;
    background: rgba(255,255,255,0.05);
    border-radius: 50%;
    border: 2px solid #7f3cff;
    position: relative;
    touch-action: none;
}

#stick {
    width: 50px;
    height: 50px;
    background: #b56bff;
    border-radius: 50%;
    position: absolute;
    top: 35px;
    left: 35px;
    box-shadow: 0 0 15px #b56bff;
    transition: all 0.1s ease-out;
}

.buttons {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.button-row {
    display: flex;
    gap: 15px;
}

.btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: bold;
    color: white;
    user-select: none;
    transition: transform 0.1s;
}

.btn:active {
    transform: scale(0.9);
}

#btnJump {
    background: rgba(0,255,255,0.3);
    border: 2px solid cyan;
    box-shadow: 0 0 15px cyan;
}

#btnJump.charging {
    background: rgba(0,255,0,0.5);
    box-shadow: 0 0 25px #00ff00;
}

#btnFly {
    background: rgba(138,43,226,0.3);
    border: 2px solid #8a2be2;
    box-shadow: 0 0 15px #8a2be2;
}

#btnUse {
    background: rgba(255,215,0,0.3);
    border: 2px solid gold;
    box-shadow: 0 0 15px gold;
}

.btn.disabled {
    opacity: 0.3;
    pointer-events: none;
}

/* PORTAL ANIMATION */
@keyframes portalPulse {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.1); opacity: 1; }
}

.portal-hint {
    position: fixed;
    bottom: 150px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    padding: 15px 30px;
    border-radius: 10px;
    color: #fff;
    font-size: 18px;
    text-align: center;
    border: 2px solid #ff00ff;
    box-shadow: 0 0 20px #ff00ff;
    z-index: 100;
    display: none;
    animation: portalPulse 2s infinite;
}
</style>
</head>

<body>

<div class="ui" id="mainUI">
    <div class="score-display">üéµ SCORE: <span id="scoreValue">0</span></div>
    <div class="era-display" id="eraDisplay">üåå ERA: UNKNOWN</div>
    <div id="status">ESTADO: SOBRIO</div>
    <div id="distance">DISTANCIA: <span id="distanceValue">0</span>m</div>
    <div id="power">ENERG√çA: <span id="powerValue">100</span>%</div>
    <div class="power-bar">
        <div class="power-fill" id="powerFill" style="width: 100%"></div>
    </div>
    <div id="jumpChargeLabel" style="display:none;">CARGA SALTO: <span id="jumpChargeValue">0</span>%</div>
    <div class="jump-charge-bar" id="jumpChargeBar" style="display:none;">
        <div class="jump-charge-fill" id="jumpChargeFill" style="width: 0%"></div>
    </div>
</div>

<div class="portal-hint" id="portalHint">
    üö™ PRESIONA ‚Üë PARA ENTRAR AL PORTAL
</div>

<div class="inventory">
    <div class="item-slot" id="percSlot">
        <canvas id="percIcon" width="40" height="40"></canvas>
        <div class="item-count" id="percCount">0</div>
    </div>
    <div class="item-slot" id="leanSlot">
        <canvas id="leanIcon" width="40" height="40"></canvas>
        <div class="item-count" id="leanCount">0</div>
    </div>
    <div class="item-slot" id="weedSlot">
        <canvas id="weedIcon" width="40" height="40"></canvas>
        <div class="item-count" id="weedCount">0</div>
    </div>
</div>

<div class="controls">
    <div id="joystick">
        <div id="stick"></div>
    </div>

    <div class="buttons">
        <div class="button-row">
            <div class="btn" id="btnJump">SALTO</div>
            <div class="btn disabled" id="btnFly">VOLAR</div>
        </div>
        <div class="button-row">
            <div class="btn" id="btnUse">USAR</div>
        </div>
    </div>
</div>

<canvas id="game"></canvas>

<script>
// Dibujar iconos
function drawPercIcon() {
    const canvas = document.getElementById('percIcon');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 40, 40);
    const gradient = ctx.createRadialGradient(20, 20, 5, 20, 20, 15);
    gradient.addColorStop(0, '#4da6ff');
    gradient.addColorStop(1, '#0066cc');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(20, 20, 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.beginPath();
    ctx.arc(15, 15, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('P', 20, 21);
}

function drawLeanIcon() {
    const canvas = document.getElementById('leanIcon');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 40, 40);
    ctx.fillStyle = '#fff';
    ctx.fillRect(12, 15, 16, 18);
    const gradient = ctx.createLinearGradient(12, 20, 12, 33);
    gradient.addColorStop(0, '#a855f7');
    gradient.addColorStop(1, '#6b21a8');
    ctx.fillStyle = gradient;
    ctx.fillRect(13, 20, 14, 12);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(12, 15, 16, 18);
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(25, 15);
    ctx.lineTo(28, 8);
    ctx.stroke();
}

function drawWeedIcon() {
    const canvas = document.getElementById('weedIcon');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 40, 40);
    ctx.fillStyle = '#22c55e';
    ctx.beginPath();
    ctx.moveTo(20, 10);
    ctx.lineTo(18, 20);
    ctx.lineTo(20, 28);
    ctx.lineTo(22, 20);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(14, 15);
    ctx.lineTo(12, 22);
    ctx.lineTo(16, 24);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(26, 15);
    ctx.lineTo(28, 22);
    ctx.lineTo(24, 24);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(16, 22);
    ctx.lineTo(14, 28);
    ctx.lineTo(18, 28);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(24, 22);
    ctx.lineTo(26, 28);
    ctx.lineTo(22, 28);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#16a34a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(20, 28);
    ctx.lineTo(20, 32);
    ctx.stroke();
}

drawPercIcon();
drawLeanIcon();
drawWeedIcon();

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

const GRAVITY = 0.6;
const CHUNK_SIZE = 1500; // Tama√±o de cada chunk del mundo
const PORTAL_WIDTH = 100;

let cameraX = 0;
let cameraY = 0;
let gameTime = 0;
let score = 0;
let totalDistance = 0;
let currentChunk = 0;
let transitionProgress = 0;
let isTransitioning = false;

// Eras de Juice WRLD
const ERAS = {
    GBGR: {
        name: "Goodbye & Good Riddance",
        colors: {
            bg1: "#0a0015",
            bg2: "#1a0030",
            bg3: "#0f001a",
            platform: "#250035",
            accent: "#7f3cff",
            particle: "#ff00ff"
        },
        icon: "üíî"
    },
    DRFL: {
        name: "Death Race for Love",
        colors: {
            bg1: "#1a0500",
            bg2: "#300a00",
            bg3: "#1a0000",
            platform: "#350015",
            accent: "#ff3c3c",
            particle: "#ff8800"
        },
        icon: "üèéÔ∏è"
    },
    LND: {
        name: "Legends Never Die",
        colors: {
            bg1: "#0f0f1a",
            bg2: "#1f1f30",
            bg3: "#15151a",
            platform: "#2a2a40",
            accent: "#ffd700",
            particle: "#ffffff"
        },
        icon: "üëº"
    },
    FD: {
        name: "Fighting Demons",
        colors: {
            bg1: "#001a0a",
            bg2: "#003015",
            bg3: "#001a00",
            platform: "#153525",
            accent: "#3cff7f",
            particle: "#00ff88"
        },
        icon: "‚öîÔ∏è"
    }
};

const ERA_SEQUENCE = ['GBGR', 'DRFL', 'LND', 'FD'];
let currentEraIndex = 0;
let currentEra = ERAS[ERA_SEQUENCE[0]];

// Part√≠culas
const particles = [];
const tripParticles = [];

// Player
const player = {
    x: 150,
    y: 100,
    w: 20,
    h: 40,
    vx: 0,
    vy: 0,
    speed: 4,
    jumpPower: 12,
    maxJumpPower: 20,
    jumpCharge: 0,
    isCharging: false,
    grounded: false,
    dir: 1,
    animFrame: 0,
    power: 100,
    maxPower: 100,
    canFly: false,
    isFlying: false,
    flyPower: 0.8,
    tripLevel: 0,
    glowIntensity: 0,
    trailColor: '#ff00ff',
    speedBoost: false,
    inventory: {
        percs: 0,
        lean: 0,
        weed: 0
    },
    nearPortal: false
};

const input = { 
    x: 0, 
    jump: false, 
    jumpPressed: false,
    fly: false,
    use: false,
    usePressed: false,
    up: false
};

// Sistema de chunks procedurales
let chunks = [];
let activePortal = null;

function generatePlatformCluster(startX, baseY, difficulty) {
    const platforms = [];
    const numPlatforms = 3 + Math.floor(Math.random() * 3 + difficulty);
    
    let currentX = startX;
    let currentY = baseY;
    
    for (let i = 0; i < numPlatforms; i++) {
        const width = 100 + Math.random() * 150;
        const gap = 100 + Math.random() * 200 + difficulty * 50;
        const heightChange = (Math.random() - 0.5) * 200;
        
        currentX += gap;
        currentY = Math.max(200, Math.min(canvas.height - 200, currentY + heightChange));
        
        platforms.push({
            x: currentX,
            y: currentY,
            w: width,
            h: 20,
            type: 'platform'
        });
        
        // Posibilidad de barrera
        if (Math.random() < 0.3 + difficulty * 0.1) {
            platforms.push({
                x: currentX + width + 50,
                y: currentY - 200 - Math.random() * 200,
                w: 30,
                h: 400,
                type: 'barrier'
            });
        }
    }
    
    return platforms;
}

function generateChunk(chunkIndex) {
    const startX = chunkIndex * CHUNK_SIZE;
    const difficulty = Math.min(chunkIndex * 0.1, 2);
    
    const chunk = {
        index: chunkIndex,
        startX: startX,
        endX: startX + CHUNK_SIZE,
        platforms: [],
        items: [],
        notes: []
    };
    
    // Suelo base
    chunk.platforms.push({
        x: startX,
        y: canvas.height - 100,
        w: CHUNK_SIZE,
        h: 100,
        type: 'floor'
    });
    
    // Generar clusters de plataformas
    const numClusters = 2 + Math.floor(difficulty);
    for (let i = 0; i < numClusters; i++) {
        const clusterStart = startX + 200 + i * (CHUNK_SIZE / numClusters);
        const baseY = canvas.height - 200 - Math.random() * 300;
        chunk.platforms.push(...generatePlatformCluster(clusterStart, baseY, difficulty));
    }
    
    // Generar items
    const numItems = 3 + Math.floor(Math.random() * 4);
    for (let i = 0; i < numItems; i++) {
        const itemX = startX + 300 + Math.random() * (CHUNK_SIZE - 600);
        const itemY = canvas.height - 200 - Math.random() * 400;
        
        const itemTypes = ['perc', 'lean', 'weed'];
        const weights = [0.4, 0.35, 0.25];
        const rand = Math.random();
        let itemType = itemTypes[0];
        let cumulative = 0;
        for (let j = 0; j < weights.length; j++) {
            cumulative += weights[j];
            if (rand < cumulative) {
                itemType = itemTypes[j];
                break;
            }
        }
        
        chunk.items.push({
            x: itemX,
            y: itemY,
            type: itemType,
            collected: false
        });
    }
    
    // Generar notas musicales
    const numNotes = 10 + Math.floor(Math.random() * 10);
    for (let i = 0; i < numNotes; i++) {
        chunk.notes.push({
            x: startX + 200 + Math.random() * (CHUNK_SIZE - 400),
            y: canvas.height - 200 - Math.random() * 500,
            collected: false,
            floatOffset: Math.random() * Math.PI * 2,
            value: 10
        });
    }
    
    return chunk;
}

function createPortal(x) {
    return {
        x: x,
        y: canvas.height - 250,
        w: PORTAL_WIDTH,
        h: 150,
        active: true,
        nextEra: ERA_SEQUENCE[(currentEraIndex + 1) % ERA_SEQUENCE.length]
    };
}

// Inicializar chunks
for (let i = 0; i < 3; i++) {
    chunks.push(generateChunk(i));
}
activePortal = createPortal(CHUNK_SIZE * 0.9);

// Decoraciones
const decorations = [];
function regenerateStars() {
    decorations.length = 0;
    for (let i = 0; i < 100; i++) {
        decorations.push({
            x: Math.random() * canvas.width * 10,
            y: Math.random() * canvas.height * 0.6,
            size: Math.random() * 3 + 1,
            opacity: Math.random() * 0.5 + 0.3,
            hue: Math.random() * 360
        });
    }
}
regenerateStars();

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PART√çCULAS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function createParticle(x, y, color, size = 3) {
    particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 6,
        vy: (Math.random() - 0.5) * 6,
        life: 1,
        color,
        size
    });
}

function createTripParticle(x, y) {
    tripParticles.push({
        x, y,
        vx: (Math.random() - 0.5) * 3,
        vy: (Math.random() - 0.5) * 3,
        life: 1,
        hue: Math.random() * 360,
        size: Math.random() * 8 + 4
    });
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.02;
        if (p.life <= 0) particles.splice(i, 1);
    }
    
    for (let i = tripParticles.length - 1; i >= 0; i--) {
        const p = tripParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.hue = (p.hue + 5) % 360;
        p.life -= 0.01;
        if (p.life <= 0) tripParticles.splice(i, 1);
    }
    
    if (player.isFlying && gameTime % 2 === 0) {
        createParticle(player.x, player.y, player.trailColor, 4);
    }
    
    if (player.tripLevel > 0 && gameTime % 3 === 0) {
        createTripParticle(player.x + (Math.random() - 0.5) * 30, player.y + (Math.random() - 0.5) * 30);
    }
}

function drawParticles() {
    particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = p.color;
        ctx.fillRect(p.x - cameraX, p.y - cameraY, p.size, p.size);
        ctx.restore();
    });
    
    tripParticles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life * 0.8;
        ctx.fillStyle = `hsl(${p.hue}, 100%, 60%)`;
        ctx.shadowBlur = 20;
        ctx.shadowColor = `hsl(${p.hue}, 100%, 60%)`;
        ctx.beginPath();
        ctx.arc(p.x - cameraX, p.y - cameraY, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PORTAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function drawPortal(portal) {
    if (!portal || !portal.active) return;
    
    const screenX = portal.x - cameraX;
    const screenY = portal.y - cameraY;
    
    if (screenX < -200 || screenX > canvas.width + 200) return;
    
    ctx.save();
    
    // Efecto de portal giratorio
    const rotation = gameTime * 0.05;
    ctx.translate(screenX + portal.w/2, screenY + portal.h/2);
    
    // C√≠rculos conc√©ntricos
    for (let i = 5; i > 0; i--) {
        const radius = (portal.w/2) * (i/5) * (1 + Math.sin(gameTime * 0.1 + i) * 0.1);
        const nextEra = ERAS[portal.nextEra];
        
        ctx.strokeStyle = nextEra.colors.accent;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 20;
        ctx.shadowColor = nextEra.colors.accent;
        ctx.globalAlpha = 0.3 + (i/5) * 0.4;
        
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Part√≠culas del portal
    if (gameTime % 3 === 0) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * portal.w/2;
        createParticle(
            portal.x + portal.w/2 + Math.cos(angle) * radius,
            portal.y + portal.h/2 + Math.sin(angle) * radius,
            ERAS[portal.nextEra].colors.accent,
            4
        );
    }
    
    // Texto central
    ctx.globalAlpha = 0.8 + Math.sin(gameTime * 0.1) * 0.2;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(ERAS[portal.nextEra].icon, 0, -30);
    ctx.font = '14px monospace';
    ctx.fillText('NEXT ERA', 0, 0);
    
    ctx.restore();
}

function checkPortalCollision() {
    if (!activePortal || !activePortal.active) return;
    
    const dist = Math.abs(player.x - (activePortal.x + activePortal.w/2));
    
    if (dist < 100) {
        player.nearPortal = true;
        document.getElementById('portalHint').style.display = 'block';
        
        if (input.up && !isTransitioning) {
            enterPortal();
        }
    } else {
        player.nearPortal = false;
        document.getElementById('portalHint').style.display = 'none';
    }
}

function enterPortal() {
    isTransitioning = true;
    transitionProgress = 0;
    
    // Cambiar era
    currentEraIndex = (currentEraIndex + 1) % ERA_SEQUENCE.length;
    currentEra = ERAS[ERA_SEQUENCE[currentEraIndex]];
    
    // Actualizar UI
    document.getElementById('eraDisplay').textContent = `${currentEra.icon} ERA: ${currentEra.name.toUpperCase()}`;
    document.getElementById('mainUI').style.color = currentEra.colors.accent;
    
    // Efectos visuales masivos
    for (let i = 0; i < 100; i++) {
        createParticle(player.x, player.y, currentEra.colors.accent, 6);
        createTripParticle(player.x, player.y);
    }
    
    // Regenerar mundo
    setTimeout(() => {
        // Limpiar chunks viejos
        chunks = [];
        currentChunk = 0;
        
        // Generar nuevos chunks
        for (let i = 0; i < 3; i++) {
            chunks.push(generateChunk(i));
        }
        
        // Crear nuevo portal
        activePortal = createPortal(CHUNK_SIZE * 0.9);
        
        // Resetear posici√≥n del jugador
        player.x = 150;
        player.y = 100;
        cameraX = 0;
        
        // Regenerar estrellas
        regenerateStars();
        
        isTransitioning = false;
        document.getElementById('portalHint').style.display = 'none';
    }, 1000);
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ITEMS Y NOTAS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function drawItems() {
    chunks.forEach(chunk => {
        chunk.items.forEach(item => {
            if (item.collected) return;
            
            const screenX = item.x - cameraX;
            const screenY = item.y - cameraY;
            
            if (screenX > -50 && screenX < canvas.width + 50) {
                ctx.save();
                
                const floatOffset = Math.sin(gameTime * 0.1 + item.x) * 5;
                const finalY = screenY + floatOffset;
                
                ctx.shadowBlur = 20;
                
                if (item.type === 'perc') {
                    ctx.shadowColor = '#0066cc';
                    const gradient = ctx.createRadialGradient(screenX, finalY, 3, screenX, finalY, 10);
                    gradient.addColorStop(0, '#4da6ff');
                    gradient.addColorStop(1, '#0066cc');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, finalY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('P', screenX, finalY + 4);
                } else if (item.type === 'lean') {
                    ctx.shadowColor = '#a855f7';
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(screenX - 6, finalY - 8, 12, 12);
                    ctx.fillStyle = '#a855f7';
                    ctx.fillRect(screenX - 5, finalY - 3, 10, 7);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 4, finalY - 8);
                    ctx.lineTo(screenX + 6, finalY - 12);
                    ctx.stroke();
                } else if (item.type === 'weed') {
                    ctx.shadowColor = '#22c55e';
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.moveTo(screenX, finalY - 8);
                    ctx.lineTo(screenX - 3, finalY);
                    ctx.lineTo(screenX, finalY + 6);
                    ctx.lineTo(screenX + 3, finalY);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, finalY, 18, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
        });
    });
}

function drawMusicalNotes() {
    chunks.forEach(chunk => {
        chunk.notes.forEach(note => {
            if (note.collected) return;
            
            const screenX = note.x - cameraX;
            const screenY = note.y - cameraY;
            
            if (screenX > -50 && screenX < canvas.width + 50) {
                ctx.save();
                
                note.floatOffset += 0.05;
                const floatY = screenY + Math.sin(note.floatOffset) * 8;
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffd700';
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 24px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ô™', screenX, floatY);
                
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, floatY, 20, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
        });
    });
}

function checkCollectibles() {
    chunks.forEach(chunk => {
        // Items
        chunk.items.forEach(item => {
            if (item.collected) return;
            const dist = Math.hypot(player.x - item.x, player.y - 20 - item.y);
            if (dist < 25) {
                item.collected = true;
                for (let i = 0; i < 15; i++) {
                    const color = item.type === 'perc' ? '#0066cc' : item.type === 'lean' ? '#a855f7' : '#22c55e';
                    createParticle(item.x, item.y, color, 5);
                }
                if (item.type === 'perc') {
                    player.inventory.percs++;
                    document.getElementById('percCount').textContent = player.inventory.percs;
                } else if (item.type === 'lean') {
                    player.inventory.lean++;
                    document.getElementById('leanCount').textContent = player.inventory.lean;
                } else {
                    player.inventory.weed++;
                    document.getElementById('weedCount').textContent = player.inventory.weed;
                }
            }
        });
        
        // Notas
        chunk.notes.forEach(note => {
            if (note.collected) return;
            const dist = Math.hypot(player.x - note.x, player.y - 20 - note.y);
            if (dist < 30) {
                note.collected = true;
                score += note.value;
                document.getElementById('scoreValue').textContent = score;
                for (let i = 0; i < 10; i++) {
                    createParticle(note.x, note.y, '#ffd700', 4);
                }
            }
        });
    });
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ USAR ITEMS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function useItem() {
    if (player.inventory.percs > 0) {
        player.inventory.percs--;
        document.getElementById('percCount').textContent = player.inventory.percs;
        player.canFly = true;
        player.power = 100;
        player.trailColor = '#0066cc';
        player.glowIntensity = 1;
        document.getElementById('btnFly').classList.remove('disabled');
        document.getElementById('status').textContent = 'ESTADO: VOLANDO ‚úàÔ∏è';
        for (let i = 0; i < 30; i++) createParticle(player.x, player.y, '#0066cc', 6);
    } else if (player.inventory.lean > 0) {
        player.inventory.lean--;
        document.getElementById('leanCount').textContent = player.inventory.lean;
        const originalSpeed = player.speed;
        player.speed = 8;
        player.trailColor = '#a855f7';
        player.glowIntensity = 0.8;
        player.speedBoost = true;
        document.getElementById('status').textContent = 'ESTADO: ACELERADO ‚ö°';
        setTimeout(() => {
            player.speed = originalSpeed;
            player.speedBoost = false;
            if (!player.canFly && player.tripLevel === 0) {
                document.getElementById('status').textContent = 'ESTADO: SOBRIO';
                player.glowIntensity = 0;
            }
        }, 5000);
        for (let i = 0; i < 20; i++) createParticle(player.x, player.y, '#a855f7', 5);
    } else if (player.inventory.weed > 0) {
        player.inventory.weed--;
        document.getElementById('weedCount').textContent = player.inventory.weed;
        player.tripLevel = 1;
        document.getElementById('status').textContent = 'ESTADO: TRIPEANDO üåà';
        setTimeout(() => {
            player.tripLevel = 0;
            if (!player.canFly && !player.speedBoost) {
                document.getElementById('status').textContent = 'ESTADO: SOBRIO';
            }
        }, 8000);
        for (let i = 0; i < 40; i++) createTripParticle(player.x, player.y);
    }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PLAYER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function drawPlayer(p) {
    ctx.save();
    const screenX = p.x - cameraX;
    const screenY = p.y - cameraY;
    ctx.translate(screenX, screenY);
    if (p.dir < 0) ctx.scale(-1, 1);
    
    if (p.glowIntensity > 0) {
        ctx.shadowBlur = 20 + p.glowIntensity * 20;
        ctx.shadowColor = p.trailColor;
    } else {
        ctx.shadowBlur = 10;
        ctx.shadowColor = currentEra.colors.particle;
    }
    
    const bobOffset = p.grounded && Math.abs(p.vx) > 0.1 ? Math.sin(p.animFrame * 0.5) * 2 : 0;
    
    ctx.strokeStyle = "#1a1a1a";
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    const legOffset = Math.sin(p.animFrame * 0.3) * 5;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-4 + legOffset, 15);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(4 - legOffset, 15);
    ctx.stroke();
    
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    ctx.moveTo(0, -18 + bobOffset);
    ctx.lineTo(0, 0);
    ctx.stroke();
    
    ctx.lineWidth = 2.5;
    const armSwing = Math.sin(p.animFrame * 0.3) * 8;
    ctx.beginPath();
    ctx.moveTo(0, -14 + bobOffset);
    ctx.lineTo(-8 - armSwing, -5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, -14 + bobOffset);
    ctx.lineTo(8 + armSwing, -5);
    ctx.stroke();
    
    ctx.fillStyle = "#0a0a0a";
    ctx.beginPath();
    ctx.arc(0, -24 + bobOffset, 6, 0, Math.PI * 2);
    ctx.fill();
    
    const dreadColor = p.canFly ? '#0066cc' : (p.speedBoost ? '#a855f7' : (p.tripLevel > 0 ? `hsl(${gameTime * 10 % 360}, 100%, 60%)` : currentEra.colors.accent));
    ctx.strokeStyle = dreadColor;
    ctx.lineWidth = 2;
    for (let i = -6; i <= 6; i += 3) {
        ctx.beginPath();
        ctx.moveTo(i, -29 + bobOffset);
        const wave = Math.sin(Date.now() / 200 + i) * 3;
        ctx.lineTo(i + wave, -38 + bobOffset);
        ctx.stroke();
    }
    
    const eyeColor = p.isFlying ? '#0066cc' : (p.isCharging ? '#00ff00' : '#00ffff');
    ctx.fillStyle = eyeColor;
    ctx.shadowColor = eyeColor;
    ctx.shadowBlur = p.isCharging ? 15 : 5;
    ctx.fillRect(-3, -26 + bobOffset, 2, 2);
    ctx.fillRect(1, -26 + bobOffset, 2, 2);
    
    ctx.restore();
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COLISIONES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function checkCollision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.w &&
           rect1.x + rect1.w > rect2.x &&
           rect1.y < rect2.y + rect2.h &&
           rect1.y + rect1.h > rect2.y;
}

function getAllPlatforms() {
    let allPlatforms = [];
    chunks.forEach(chunk => {
        allPlatforms.push(...chunk.platforms);
    });
    return allPlatforms;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function update() {
    if (isTransitioning) {
        transitionProgress += 0.02;
        return;
    }
    
    gameTime++;
    
    player.vx = input.x * player.speed;
    player.x += player.vx;
    
    if (player.vx !== 0) {
        player.dir = player.vx > 0 ? 1 : -1;
        player.animFrame += 0.2;
    }
    
    // Sistema de carga de salto
    if (input.jump && player.grounded && !input.jumpPressed) {
        player.isCharging = true;
        player.jumpCharge = Math.min(100, player.jumpCharge + 3);
        document.getElementById('jumpChargeBar').style.display = 'block';
        document.getElementById('jumpChargeLabel').style.display = 'block';
        document.getElementById('jumpChargeValue').textContent = Math.floor(player.jumpCharge);
        document.getElementById('jumpChargeFill').style.width = player.jumpCharge + '%';
        document.getElementById('btnJump').classList.add('charging');
        if (gameTime % 3 === 0 && player.jumpCharge > 20) {
            createParticle(player.x + (Math.random() - 0.5) * 15, player.y, '#00ff00', 3);
        }
    }
    
    if (!input.jump && player.isCharging) {
        const chargePercent = player.jumpCharge / 100;
        const jumpForce = player.jumpPower + (player.maxJumpPower - player.jumpPower) * chargePercent;
        player.vy = -jumpForce;
        player.grounded = false;
        player.isCharging = false;
        player.jumpCharge = 0;
        input.jumpPressed = true;
        document.getElementById('jumpChargeBar').style.display = 'none';
        document.getElementById('jumpChargeLabel').style.display = 'none';
        document.getElementById('btnJump').classList.remove('charging');
        const particleCount = Math.floor(5 + chargePercent * 15);
        for (let i = 0; i < particleCount; i++) {
            createParticle(player.x, player.y, '#00ff00', 5);
        }
    }
    
    // Sistema de vuelo
    if (player.canFly) {
        if (input.fly && player.power > 0) {
            player.isFlying = true;
            player.vy = -player.flyPower * 10;
            player.power -= player.flyPower;
            if (gameTime % 2 === 0) createParticle(player.x, player.y + 10, '#0066cc', 5);
        } else {
            player.isFlying = false;
        }
        
        if (player.power <= 0) {
            player.canFly = false;
            player.isFlying = false;
            player.glowIntensity = 0;
            document.getElementById('btnFly').classList.add('disabled');
            if (player.tripLevel === 0 && !player.speedBoost) {
                document.getElementById('status').textContent = 'ESTADO: SOBRIO';
            }
        }
        
        document.getElementById('powerValue').textContent = Math.floor(player.power);
        document.getElementById('powerFill').style.width = player.power + '%';
    }
    
    if (!player.isFlying) {
        player.vy += GRAVITY;
    } else {
        player.vy *= 0.9;
    }
    
    player.y += player.vy;
    
    // Gesti√≥n de chunks
    const playerChunk = Math.floor(player.x / CHUNK_SIZE);
    if (playerChunk > currentChunk) {
        currentChunk = playerChunk;
        // Generar nuevo chunk adelante
        if (!chunks.find(c => c.index === currentChunk + 2)) {
            chunks.push(generateChunk(currentChunk + 2));
        }
        // Eliminar chunks atr√°s
        chunks = chunks.filter(c => c.index >= currentChunk - 1);
        
        // Mover portal
        activePortal = createPortal((currentChunk + 1) * CHUNK_SIZE - CHUNK_SIZE * 0.1);
    }
    
    // Colisiones
    player.grounded = false;
    const platforms = getAllPlatforms();
    
    platforms.forEach(plat => {
        const playerRect = {
            x: player.x - player.w/2,
            y: player.y - player.h,
            w: player.w,
            h: player.h
        };
        
        if (checkCollision(playerRect, plat)) {
            if (plat.type === 'barrier') {
                if (!player.isFlying) {
                    if (player.vx > 0) player.x = plat.x - player.w/2;
                    else if (player.vx < 0) player.x = plat.x + plat.w + player.w/2;
                    player.vx = 0;
                }
                return;
            }
            
            if (player.vy > 0 && playerRect.y + playerRect.h - player.vy < plat.y + 10) {
                player.y = plat.y;
                player.vy = 0;
                player.grounded = true;
            }
            else if (player.vy < 0 && playerRect.y - player.vy > plat.y + plat.h - 10) {
                player.y = plat.y + plat.h + player.h;
                player.vy = 0;
            }
            else if (plat.type === 'wall') {
                if (player.vx > 0) player.x = plat.x - player.w/2;
                else if (player.vx < 0) player.x = plat.x + plat.w + player.w/2;
                player.vx = 0;
            }
        }
    });
    
    if (!input.jump) input.jumpPressed = false;
    
    if (input.use && !input.usePressed) {
        useItem();
        input.usePressed = true;
    }
    if (!input.use) input.usePressed = false;
    
    checkCollectibles();
    checkPortalCollision();
    updateParticles();
    
    // C√°mara
    const targetCameraX = player.x - canvas.width / 2;
    cameraX += (targetCameraX - cameraX) * 0.1;
    cameraX = Math.max(0, cameraX);
    
    // Actualizar distancia
    totalDistance = Math.floor(player.x / 10);
    document.getElementById('distanceValue').textContent = totalDistance;
    
    if (player.tripLevel > 0) {
        player.tripLevel = Math.max(0, player.tripLevel - 0.001);
    }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DRAW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function drawBackground() {
    const colors = currentEra.colors;
    
    if (player.tripLevel > 0) {
        const hue1 = (gameTime * 2) % 360;
        const hue2 = (gameTime * 2 + 180) % 360;
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, `hsl(${hue1}, 70%, 10%)`);
        g.addColorStop(0.5, `hsl(${hue2}, 70%, 15%)`);
        g.addColorStop(1, `hsl(${hue1}, 70%, 10%)`);
        ctx.fillStyle = g;
    } else {
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, colors.bg1);
        g.addColorStop(0.5, colors.bg2);
        g.addColorStop(1, colors.bg3);
        ctx.fillStyle = g;
    }
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Estrellas
    decorations.forEach(star => {
        const parallaxX = (star.x - cameraX * 0.3);
        if (parallaxX < -10 || parallaxX > canvas.width + 10) return;
        
        if (player.tripLevel > 0) {
            const hue = (star.hue + gameTime * 2) % 360;
            ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${star.opacity})`;
        } else {
            ctx.fillStyle = `rgba(${hexToRgb(colors.particle)}, ${star.opacity})`;
        }
        ctx.fillRect(parallaxX, star.y, star.size, star.size);
    });
    
    // Grid
    ctx.strokeStyle = player.tripLevel > 0 ? `hsla(${gameTime * 5 % 360}, 70%, 50%, 0.2)` : colors.accent + '33';
    ctx.lineWidth = 1;
    
    const gridSize = 50;
    const startX = Math.floor(cameraX / gridSize) * gridSize;
    
    for (let x = startX; x < cameraX + canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x - cameraX, 0);
        ctx.lineTo(x - cameraX, canvas.height);
        ctx.stroke();
    }
    
    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3), 16);
    const g = parseInt(hex.slice(3,5), 16);
    const b = parseInt(hex.slice(5,7), 16);
    return `${r}, ${g}, ${b}`;
}

function drawPlatforms() {
    const platforms = getAllPlatforms();
    const colors = currentEra.colors;
    
    platforms.forEach(plat => {
        const screenX = plat.x - cameraX;
        const screenY = plat.y - cameraY;
        
        if (screenX + plat.w > 0 && screenX < canvas.width) {
            ctx.save();
            
            if (plat.type === 'barrier') {
                ctx.shadowBlur = 20;
                ctx.shadowColor = "#ff0000";
                ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
                ctx.fillRect(screenX, screenY, plat.w, plat.h);
                ctx.strokeStyle = "#ff0000";
                ctx.lineWidth = 2;
                for (let i = 0; i < plat.h; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY + i);
                    ctx.lineTo(screenX + plat.w, screenY + i + 10);
                    ctx.stroke();
                }
            } else {
                ctx.shadowBlur = 15;
                ctx.shadowColor = colors.accent;
                ctx.fillStyle = colors.platform;
                ctx.fillRect(screenX, screenY, plat.w, plat.h);
                ctx.strokeStyle = colors.accent;
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, plat.w, plat.h);
                
                if (plat.w > 100 && plat.type !== 'wall') {
                    ctx.strokeStyle = colors.accent + '55';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < plat.w; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + i, screenY);
                        ctx.lineTo(screenX + i, screenY + plat.h);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.restore();
        }
    });
}

function draw() {
    drawBackground();
    drawPlatforms();
    drawPortal(activePortal);
    drawMusicalNotes();
    drawItems();
    drawParticles();
    drawPlayer(player);
    
    // Transici√≥n de era
    if (isTransitioning) {
        ctx.fillStyle = `rgba(255, 255, 255, ${transitionProgress})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    requestAnimationFrame(() => {
        update();
        draw();
    });
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CONTROLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const joystick = document.getElementById("joystick");
const stick = document.getElementById("stick");
let joyActive = false;

function handleJoystickStart(e) {
    joyActive = true;
    e.preventDefault();
}

function handleJoystickMove(e) {
    if (!joyActive) return;
    e.preventDefault();
    const rect = joystick.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : e;
    let dx = touch.clientX - (rect.left + rect.width/2);
    let dy = touch.clientY - (rect.top + rect.height/2);
    const dist = Math.min(40, Math.hypot(dx, dy));
    const angle = Math.atan2(dy, dx);
    stick.style.left = 35 + Math.cos(angle) * dist + "px";
    stick.style.top = 35 + Math.sin(angle) * dist + "px";
    input.x = dist > 10 ? Math.cos(angle) : 0;
}

function handleJoystickEnd(e) {
    joyActive = false;
    stick.style.left = "35px";
    stick.style.top = "35px";
    input.x = 0;
    e.preventDefault();
}

joystick.addEventListener("touchstart", handleJoystickStart);
joystick.addEventListener("touchmove", handleJoystickMove);
joystick.addEventListener("touchend", handleJoystickEnd);
joystick.addEventListener("touchcancel", handleJoystickEnd);
joystick.addEventListener("mousedown", handleJoystickStart);
joystick.addEventListener("mousemove", handleJoystickMove);
joystick.addEventListener("mouseup", handleJoystickEnd);
joystick.addEventListener("mouseleave", handleJoystickEnd);

const btnJump = document.getElementById("btnJump");
const btnFly = document.getElementById("btnFly");
const btnUse = document.getElementById("btnUse");

btnJump.addEventListener("touchstart", (e) => { e.preventDefault(); input.jump = true; });
btnJump.addEventListener("touchend", (e) => { e.preventDefault(); input.jump = false; });
btnJump.addEventListener("mousedown", (e) => { e.preventDefault(); input.jump = true; });
btnJump.addEventListener("mouseup", (e) => { e.preventDefault(); input.jump = false; });

btnFly.addEventListener("touchstart", (e) => { e.preventDefault(); input.fly = true; });
btnFly.addEventListener("touchend", (e) => { e.preventDefault(); input.fly = false; });
btnFly.addEventListener("mousedown", (e) => { e.preventDefault(); input.fly = true; });
btnFly.addEventListener("mouseup", (e) => { e.preventDefault(); input.fly = false; });

btnUse.addEventListener("touchstart", (e) => { e.preventDefault(); input.use = true; });
btnUse.addEventListener("touchend", (e) => { e.preventDefault(); input.use = false; });
btnUse.addEventListener("mousedown", (e) => { e.preventDefault(); input.use = true; });
btnUse.addEventListener("mouseup", (e) => { e.preventDefault(); input.use = false; });

window.addEventListener("keydown", e => {
    if (e.key === "ArrowLeft" || e.key === "a") input.x = -1;
    if (e.key === "ArrowRight" || e.key === "d") input.x = 1;
    if (e.key === " " || e.key === "w" || e.key === "ArrowUp") {
        if (!player.nearPortal) input.jump = true;
        else input.up = true;
    }
    if (e.key === "Shift") input.fly = true;
    if (e.key === "e" || e.key === "q") input.use = true;
});

window.addEventListener("keyup", e => {
    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "ArrowRight" || e.key === "d") input.x = 0;
    if (e.key === " " || e.key === "w" || e.key === "ArrowUp") {
        input.jump = false;
        input.up = false;
    }
    if (e.key === "Shift") input.fly = false;
    if (e.key === "e" || e.key === "q") input.use = false;
});

window.addEventListener("resize", () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
});

// Inicializar
document.getElementById('eraDisplay').textContent = `${currentEra.icon} ERA: ${currentEra.name.toUpperCase()}`;
document.getElementById('mainUI').style.color = currentEra.colors.accent;

draw();
</script>
</body>
</html>
